

User
import pygame
import sys

# Initialize Pygame
pygame.init()

# Set up the screen dimensions
screen_width = 800
screen_height = 600
screen = pygame.display.set_mode((screen_width, screen_height))
pygame.display.set_caption("My Pet Skunk")

# Colors
BLACK = (0, 0, 0)
WHITE = (255, 255, 255)
GREEN = (0, 255, 0)
RED = (255, 0, 0)
BROWN = (139, 69, 19) 


# Skunk class
class Skunk(pygame.sprite.Sprite):
    def __init__(self, image, screen_width):
        super().__init__()
        self.original_image = pygame.transform.scale(pygame.image.load(image), (50, 50))
        self.image = self.original_image
        self.rect = self.image.get_rect()
        self.rect.centerx = screen_width // 2  # Center horizontally
        self.rect.centery = 2 * screen_height // 3  # 2/3 down the screen
        self.speed = 1
        self.direction = 'left'  # Start moving to the left initially
        self.flipped = False
        self.moving = True  # Flag to control movement
        self.bathed = False  # Flag to track if skunk has been bathed
        # Initialize stats
        self.happiness = 0
        self.cleanliness = 0
        self.health = 50
        self.hunger = 50
        self.friendship = 0

    def update(self, boundaries_rect):
        if self.moving:
            if self.direction == 'left':
                if self.rect.left > boundaries_rect.left:
                    self.rect.x -= self.speed
                    if not self.flipped:
                        self.image = pygame.transform.flip(self.original_image, True, False)
                        self.flipped = True
                else:
                    self.direction = 'right'
            elif self.direction == 'right':
                if self.rect.right < boundaries_rect.right:
                    self.rect.x += self.speed
                    if self.flipped:
                        self.image = self.original_image
                        self.flipped = False
                else:
                    self.direction = 'left'

    def draw(self, screen):
        screen.blit(self.image, self.rect)

    def is_clicked(self, mouse_pos):
        return self.rect.collidepoint(mouse_pos)

    def bathe(self):
        # Bathe the skunk
        # For example, change the appearance or reset any dirty state
        # For now, just toggle the bathed flag
        self.bathed = True
        # Update cleanliness
        self.cleanliness += 10  # Increment cleanliness by 10%

    def feed(self):
        # Feed the skunk
        # Update hunger
        self.hunger -= 10  # Decrease hunger by 10%
        if self.hunger < 0:
            self.hunger = 0  # Ensure hunger doesn't go below 0

    def play(self):
        # Play with the skunk
        # Update happiness and friendship
        self.happiness += 10  # Increase happiness by 10%
        self.friendship += 10  # Increase friendship by 10%
        if self.happiness > 100:
            self.happiness = 100  # Ensure happiness doesn't exceed 100
        if self.friendship > 100:
            self.friendship = 100  # Ensure friendship doesn't exceed 100

    def talk(self):
        # Talk to the skunk
        # Update happiness and friendship
        self.happiness += 5  # Increase happiness by 5%
        self.friendship += 5  # Increase friendship by 5%
        if self.happiness > 100:
            self.happiness = 100  # Ensure happiness doesn't exceed 100
        if self.friendship > 100:
            self.friendship = 100  # Ensure friendship doesn't exceed 100

    def stroke(self):
        # Stroke the skunk
        # Update happiness, cleanliness, and friendship
        self.happiness += 5  # Increase happiness by 5%
        self.cleanliness += 5  # Increase cleanliness by 5%
        self.friendship += 10  # Increase friendship by 10%
        if self.happiness > 100:
            self.happiness = 100  # Ensure happiness doesn't exceed 100
        if self.cleanliness > 100:
            self.cleanliness = 100  # Ensure cleanliness doesn't exceed 100
        if self.friendship > 100:
            self.friendship = 100  # Ensure friendship doesn't exceed 100


def aim_message(screen):
    # Font settings
    font = pygame.font.SysFont(None, 26)

    # Messages to be displayed
    breezy_message = "Meet Breezy. (press any key to continue)"
    skunk_message = "He doesn't like you very much."
    third_message = "Figure out how to fix that."

    # Calculate text size and position
    box_width = 400
    box_height = 20
    box_left = (screen_width - box_width) // 2
    box_top = 70  # Adjusted to display the message at the top

    # Create a surface for the message box
    message_box_surface = pygame.Surface((box_width, box_height))
    message_box_surface.fill((139, 69, 19))  # Brown color

    # Typewriter effect for the first message
    current_message = breezy_message
    typing_done = False
    displayed_text = ""
    while not typing_done:
        for event in pygame.event.get():
            if event.type == pygame.KEYDOWN:
                typing_done = True

        displayed_text = current_message
        text_surface = font.render(displayed_text, True, (240, 200, 160))  # Bright tan color
        text_width, text_height = text_surface.get_size()

        # Render the message onto the message box surface
        message_box_surface.blit(text_surface, ((box_width - text_width) // 2, (box_height - text_height) // 2))

        # Draw the message box onto the screen with thicker border
        pygame.draw.rect(screen, (60, 30, 10), (box_left, box_top, box_width, box_height), 3)
        screen.blit(message_box_surface, (box_left, box_top))

        # Update the display
        pygame.display.flip()

        # Pause briefly to simulate typewriter effect
        pygame.time.wait(50)  # Adjust the wait time as needed

    # Typewriter effect for the second message
    current_message = skunk_message
    displayed_text = ""
    typing_done = False
    
    while current_message:
        for event in pygame.event.get():
            if event.type == pygame.KEYDOWN:
                typing_done = True  # Exit function when a key is pressed

        displayed_text += current_message[0]
        current_message = current_message[1:]
        text_surface = font.render(displayed_text, True, (240, 200, 160))  # Bright tan color
        text_width, text_height = text_surface.get_size()

        # Render the message onto the message box surface
        message_box_surface.fill((139, 69, 19))  # Change color to brown for skunk message
        message_box_surface.blit(text_surface, ((box_width - text_width) // 2, (box_height - text_height) // 2))

        # Draw the message box onto the screen with thicker border
        pygame.draw.rect(screen, (60, 30, 10), (box_left, box_top, box_width, box_height), 3)
        screen.blit(message_box_surface, (box_left, box_top))

        # Update the display
        pygame.display.flip()

        # Pause briefly to simulate typewriter effect
        pygame.time.wait(50)  # Adjust the wait time as needed
        
        if typing_done:
            break  # Exit the loop if typing is done
    
    # Wait for a key press before transitioning to the third message
    key_pressed = False
    while not key_pressed:
        for event in pygame.event.get():
            if event.type == pygame.KEYDOWN:
                key_pressed = True

    # Typewriter effect for the third message
    current_message = third_message
    displayed_text = ""
    while current_message:
        for event in pygame.event.get():
            if event.type == pygame.KEYDOWN:
                return  # Exit function when a key is pressed

        displayed_text += current_message[0]
        current_message = current_message[1:]
        text_surface = font.render(displayed_text, True, (240, 200, 160))  # Bright tan color
        text_width, text_height = text_surface.get_size()

        # Render the message onto the message box surface
        message_box_surface.fill((139, 69, 19))  # Change color to brown for skunk message
        message_box_surface.blit(text_surface, ((box_width - text_width) // 2, (box_height - text_height) // 2))

        # Draw the message box onto the screen with thicker border
        pygame.draw.rect(screen, (60, 30, 10), (box_left, box_top, box_width, box_height), 3)
        screen.blit(message_box_surface, (box_left, box_top))

        # Update the display
        pygame.display.flip()

        # Pause briefly to simulate typewriter effect
        pygame.time.wait(50)  # Adjust the wait time as needed

    # Wait for a key press before the function exits
    key_pressed = False
    while not key_pressed:
        for event in pygame.event.get():
            if event.type == pygame.KEYDOWN:
                key_pressed = True


def main():
    clock = pygame.time.Clock()

    # Display loading screen
    loading_screen(screen)

    # Get player name
    player_name = get_player_name(screen)

    # Display title screen
    title_screen(screen, player_name)

    aunthouse_image = pygame.image.load("aunthouse.jpeg")
    aunthouse_image = pygame.transform.scale(aunthouse_image, (screen_width, screen_height))
    boundaries_rect = pygame.Rect(300, 330, 180, 250)

    skunk = Skunk("pet_skunk.png", screen_width)

    menu_font = pygame.font.SysFont(None, 24)
    menu_displayed = False

    aim_message_displayed = False  # Flag to keep track of aim message display

    while True:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()
            elif event.type == pygame.MOUSEBUTTONDOWN:
                mouse_pos = pygame.mouse.get_pos()
                if skunk.is_clicked(mouse_pos):
                    # Skunk is clicked
                    skunk.moving = False  # Stop skunk movement
                    if not menu_displayed:
                        print("Displaying menu")
                        menu_options, menu_rect = display_menu(screen, menu_font, mouse_pos)  # Get menu options and menu rectangle
                        menu_displayed = True
                    else:
                        menu_displayed = False
                        skunk.moving = True  # Resume skunk movement when menu is closed
                elif menu_displayed:
                    # Check if any menu option is clicked
                    if menu_rect.collidepoint(mouse_pos):
                        selected_option_index = (mouse_pos[1] - menu_rect.top) // 30
                        selected_option = menu_options[selected_option_index]
                        if selected_option == "BATHE":
                            skunk.bathe()  # Bathe the skunk
                        elif selected_option == "FEED":
                            skunk.feed()  # Feed the skunk
                        elif selected_option == "PLAY":
                            skunk.play()  # Play with the skunk
                        elif selected_option == "TALK":
                            skunk.talk()  # Talk to the skunk
                        elif selected_option == "STROKE":
                            skunk.stroke()  # Stroke the skunk

        screen.fill(BLACK)
        screen.blit(aunthouse_image, (0, 0))

        # Update skunk
        skunk.update(boundaries_rect)
        skunk.draw(screen)

        # Display aim message if not already displayed
        if not aim_message_displayed:
            aim_message(screen)
            aim_message_displayed = True

        if menu_displayed:
            display_menu(screen, menu_font, (skunk.rect.centerx, skunk.rect.centery - 50))

        # Display stats
        display_stats(screen, menu_font, skunk)

        pygame.display.flip()
        clock.tick(60)


def loading_screen(screen):
    # Play music
    play_music()

    # Loading progress
    loading_progress = 0

    # Main loop
    while loading_progress <= 100:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()

        # Clear the screen
        screen.fill(BLACK)

        # Draw loading text
        font = pygame.font.SysFont(None, 36)
        text = font.render("Loading...", True, WHITE)
        text_rect = text.get_rect(center=(screen_width // 2, screen_height // 2 - 50))
        screen.blit(text, text_rect)

        # Draw loading progress bar
        pygame.draw.rect(screen, GREEN, (screen_width // 2 - 150, screen_height // 2, 300, 30))
        pygame.draw.rect(screen, WHITE, (screen_width // 2 - 150, screen_height // 2, loading_progress * 3, 30))

        # Update the display
        pygame.display.flip()

        # Simulate loading progress
        loading_progress += 1
        pygame.time.wait(20)  # Adjust the wait time for smoother progress bar animation

    return True


def title_screen(screen, player_name):
    # Clear the screen
    screen.fill(BLACK)

    # Draw title text
    font = pygame.font.SysFont(None, 72)
    text = font.render("My Pet Skunk", True, WHITE)
    text_rect = text.get_rect(center=(screen_width // 2, screen_height // 2 - 100))
    screen.blit(text, text_rect)

    # Draw start button
    pygame.draw.rect(screen, GREEN, (screen_width // 2 - 100, screen_height // 2 - 25, 200, 50))
    font = pygame.font.SysFont(None, 36)
    text = font.render("Start", True, BLACK)
    text_rect = text.get_rect(center=(screen_width // 2, screen_height // 2))
    screen.blit(text, text_rect)

    # Draw quit button
    pygame.draw.rect(screen, RED, (screen_width // 2 - 100, screen_height // 2 + 75, 200, 50))
    text = font.render("Quit", True, BLACK)
    text_rect = text.get_rect(center=(screen_width // 2, screen_height // 2 + 100))
    screen.blit(text, text_rect)

    # Update the display
    pygame.display.flip()

    # Wait for the player to click the start or quit button
    while True:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()
            elif event.type == pygame.MOUSEBUTTONDOWN:
                mouse_pos = pygame.mouse.get_pos()
                if screen_width // 2 - 100 <= mouse_pos[0] <= screen_width // 2 + 100:
                    if screen_height // 2 - 25 <= mouse_pos[1] <= screen_height // 2 + 25:
                        # Start button clicked
                        stop_music()  # Stop the music
                        play_phone_ring()  # Play phone ringing sound
                        dialogue_lines = [
                            f"Hi, {player_name}, I have some news.",
                            "Aunt Gertrude is dead.",
                            "What do you mean, 'who's Aunt Gertrude?'",
                            "Okay, well, she's dead. And she left you something in her will.",
                            "No, it's not money...",
                            "She left you her pet skunk, Breezy.  No, I'm not kidding.",
                            "You need to go pick up Breezy right now. Take good care of him.",
                            "Bye."
                        ]
                        display_dialogue(screen, dialogue_lines)
                        # Update aunthouse_displayed to True
                        return True
                    elif screen_height // 2 + 75 <= mouse_pos[1] <= screen_height // 2 + 125:
                        # Quit button clicked
                        pygame.quit()
                        sys.exit()

def display_image(screen, image_path):
    # Load image
    image = pygame.image.load(image_path)
    image_rect = image.get_rect()

    # Center the image on the screen
    image_rect.center = (screen_width // 2, screen_height // 2)

    # Display the image
    screen.blit(image, image_rect)

    # Update the display
    pygame.display.flip()

    # Wait for a key press or mouse click to continue
    waiting = True
    while waiting:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()
            elif event.type == pygame.KEYDOWN or event.type == pygame.MOUSEBUTTONDOWN:
                waiting = False

def display_dialogue(screen, dialogue_lines):
    # Display dialogue lines with typewriter effect
    font = pygame.font.SysFont(None, 24)
    y_position = screen_height - 150

    for line in dialogue_lines:
        displayed_text = ""
        for char in line:
            # Render displayed text
            displayed_text += char
            text = font.render(displayed_text, True, WHITE)
            text_rect = text.get_rect(left=100, top=y_position)

            # Clear the screen
            screen.fill(BLACK)

            # Draw speech bubble
            pygame.draw.rect(screen, WHITE, (50, y_position - 30, screen_width - 100, 60), 2)

            # Blit the text onto the screen
            screen.blit(text, text_rect)

            # Update the display
            pygame.display.flip()

            # Pause briefly to simulate typewriter effect
            pygame.time.wait(30)  # Adjust the wait time as needed

        # Wait for a key press to continue to the next line
        waiting = True
        while waiting:
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    pygame.quit()
                    sys.exit()
                elif event.type == pygame.KEYDOWN or event.type == pygame.MOUSEBUTTONDOWN:
                    waiting = False

def play_phone_ring():
    # Play phone ringing sound
    pygame.mixer.Sound("phonering.mp3").play()

def play_music():
    # Play background music
    pygame.mixer.music.load("skunkmusic.mp3")
    pygame.mixer.music.play(-1)  # Loop the music indefinitely

def stop_music():
    pygame.mixer.music.stop()

def get_player_name(screen):
    # Clear the screen
    screen.fill(BLACK)

    # Draw prompt text
    font = pygame.font.SysFont(None, 36)
    text = font.render("Enter your name:", True, WHITE)
    text_rect = text.get_rect(center=(screen_width // 2, screen_height // 2 - 50))
    screen.blit(text, text_rect)

    # Update the display
    pygame.display.flip()

    # Input loop
    input_text = ""
    input_rect = pygame.Rect(screen_width // 2 - 100, screen_height // 2, 200, 50)
    active = True
    while active:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()
            elif event.type == pygame.KEYDOWN:
                if event.key == pygame.K_RETURN:
                    active = False
                elif event.key == pygame.K_BACKSPACE:
                    input_text = input_text[:-1]
                else:
                    input_text += event.unicode

        # Clear the input area
        pygame.draw.rect(screen, BLACK, input_rect)

        # Render the input text
        font = pygame.font.SysFont(None, 36)
        text_surface = font.render(input_text, True, WHITE)
        screen.blit(text_surface, (input_rect.x + 5, input_rect.y + 5))

        # Draw input area rectangle
        pygame.draw.rect(screen, WHITE, input_rect, 2)

        # Update the display
        pygame.display.flip()

    return input_text



def display_stats(screen, font, skunk):
    stats_text = [
        f"Happiness: {skunk.happiness}%",
        f"Cleanliness: {skunk.cleanliness}%",
        f"Health: {skunk.health}%",
        f"Hunger: {skunk.hunger}%",
        f"Friendship: {skunk.friendship}%"
    ]
    x = 70
    y = 70  # Adjust the initial y position to move the box further down
    y_spacing = 20  # Adjust spacing between stats
    
    # Calculate the dimensions of the brown box
    box_width = 160
    box_height = len(stats_text) * y_spacing + 10  # Adjust height based on number of stats
    box_left = 65
    box_top = 60

    # Draw the dark brown border
    border_rect = pygame.Rect(box_left, box_top, box_width, box_height)
    pygame.draw.rect(screen, (60, 30, 10), border_rect, 3)  # Increased border thickness

    # Draw the brown box
    box_rect = pygame.Rect(box_left + 3, box_top + 3, box_width - 6, box_height - 6)  # Adjusted inner box position
    pygame.draw.rect(screen, (139, 69, 19), box_rect)

    # Display stats text in brighter tan color
    tan_color = (240, 200, 160)  # Brighter tan color RGB values
    for stat in stats_text:
        text_surface = font.render(stat, True, tan_color)
        text_rect = text_surface.get_rect(left=x, top=y)
        screen.blit(text_surface, text_rect)
        y += y_spacing  # Increment y position for the next stat

def display_menu(screen, font, position):
    menu_options = ["FEED", "PLAY", "TALK", "STROKE", "BATHE"]  # Add "BATHE"
    menu_height = len(menu_options) * 30
    menu_width = 150
    menu_rect = pygame.Rect(0, 0, menu_width, menu_height)

    # Offset the menu position from the skunk's position
    menu_rect.centerx = position[0] + 25  # Offset horizontally
    menu_rect.centery = position[1] - menu_height // 2  # Offset vertically

    # Draw semi-transparent white background for the menu
    menu_surface = pygame.Surface((menu_width, menu_height))
    menu_surface.set_alpha(200)  # Set transparency (0-255)
    menu_surface.fill(WHITE)
    screen.blit(menu_surface, menu_rect)

    for i, option in enumerate(menu_options):
        text = font.render(option, True, BLACK)
        text_rect = text.get_rect(center=(menu_rect.centerx, menu_rect.top + i * 30 + 15))
        screen.blit(text, text_rect)

    pygame.display.flip()

    return menu_options, menu_rect  # Return menu options and menu rectangle




if __name__ == "__main__":
    main() 
